<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>[RubyKaigi 2017] Busting Performance Bottlenecks: Decreasing Ruby Boot time by 60%</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,400;0,9..40,500;0,9..40,600;0,9..40,700;1,9..40,400&display=swap" rel="stylesheet">
    <link href="/style-fae5a9ed.css" rel="stylesheet" />
    <link href="/site-a4df8890.css" rel="stylesheet" />
    <script src="/site.min-2a08cade.js"></script>
    <link rel="icon" href="/favicon.ico">
  </head>
  <body>
    <button type="button" class="theme-toggle" id="theme-toggle" title="Toggle dark mode" aria-label="Toggle dark mode">
      <svg class="icon-light" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"/></svg>
      <svg class="icon-dark" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"/></svg>
    </button>

    <div class="page-header">
  <div class="wrapper">
    <div class="page-back">
  <a href="/">← Back</a>
</div>

    <h1 class="page-title">Busting Performance Bottlenecks<small>Decreasing Ruby Boot time by 60%</small></h1>
    <p class="page-subtitle">Ruby Kaigi 2017, Hiroshima, Japan</p>
    <div class="embed-wrap">
      <iframe src="https://docs.google.com/presentation/d/e/2PACX-1vSedEf5lUDEWNVryXLEsnY9AqXKcUqmqt_Y0oqVDMduUnxDAYKyiM1jFc8GxS5T6CINmXirRJRTJxbc/pubembed?start=false&loop=false&delayms=10000" frameborder="0" allowfullscreen="true" mozallowfullscreen="true" width="100%" height="500" webkitallowfullscreen="true"></iframe>
      <iframe width="100%" height="500" src="https://www.youtube.com/embed/8BJKrx6rsM0?rel=0" frameborder="0" allowfullscreen></iframe>
    </div>
  </div>
</div>

<section class="page-content">
  <div class="wrapper">
    <div class="link-row">
      <a href="https://github.com/jules2689/kaigi2017demo">Github Demo Repo</a> |
      <a href="http://rubykaigi.org/2017/presentations/jules2689.html">Presentation Overview</a>
    </div>
    <div class="py-6">
  <h2 class="text-2xl font-semibold">Timing Helper</h2>
  <p>This snippet of code is very simple, but very powerful.</p>
  <p>Wrapping a block of code with this method will allow you to track how much time it takes to run</p>
  <pre>
    <code class="ruby">
  def _t(label)
    t = Process.clock_gettime(Process::CLOCK_MONOTONIC)
    ret = yield
    puts "#{label} #{Process.clock_gettime(Process::CLOCK_MONOTONIC) - t}"
    ret
  end
    </code>
  </pre>

  <h4 class="text-xl font-semibold">Example Code</h4>
  <pre>
    <code class="ruby">
  i = 0

  # This will output a basic statement
  _t('basic') do
    puts i
  end

  # This will output a basic statement
  _t('longer') do
    while i < 30
      i += 1
      sleep 0.1
    end
  end

  # _t('method') is called many times because of the recursion
  # In this case we will see many outputs for _t('method')
  # This may not be what we want, see the aggregation demo
  def my_method(i = 0)
    _t('method') do
      return if i > 20
      sleep 0.1
      my_method(i + 1)
    end
  end

  my_method
    </code>
  </pre>

  <h4 class="text-xl font-semibold">Output</h4>
  <pre>
    <code class="ruby">
  0
  basic 3.700001980178058e-05
  longer 3.099142999999458
  method 0.1033249999745749
  method 0.20763499999884516
  method 0.31305300001986325
  method 0.41850800000247546
  method 0.5237309999938589
  method 0.629190000006929
  method 0.734292999986792
  method 0.8383620000095107
  method 0.938666000001831
  method 1.0441250000149012
  method 1.1493350000237115
  method 1.2505610000225715
  method 1.3516309999977238
  method 1.4528080000018235
  method 1.5531109999865294
  method 1.6536609999893699
  method 1.757898000010755
  method 1.8631080000195652
  method 1.9683300000033341
  method 2.073551999987103
  method 2.1743229999847244
  => nil
    </code>
  </pre>
</div>

    <div class="py-6">
  <h2 class="text-2xl font-semibold">Aggregate Helper</h2>
  <p>The timing code was simple and powerful, but it didn't quite work if a line or block was called many times.</p>
  <p>To solve this, I used a global variable to keep track of how long and how many times each call is hit.</p>
  <pre>
    <code class="ruby">
  $agg = {}
  at_exit do
    line_column_size = $agg.keys.max_by(&:size).size
    time_column_size = $agg.values.max_by { |v| v[:time].to_s.size }[:time].to_s.size

    puts "| line#{' ' * (line_column_size - 4)} | num_calls | time (s)#{' ' * (time_column_size - 8)} |"
    puts "| #{'-' * line_column_size} | --------- | #{'-' * time_column_size} |"
    $agg.each do |k, v|
      line_entry = k.tr('|', '')
      line_entry << ' ' * (line_column_size - line_entry.size)

      num_calls = v[:num_calls].to_s
      num_calls << ' ' * (9 - num_calls.size)

      time = v[:time].to_s
      time << ' ' * (time_column_size - time.size)

      puts "| #{line_entry} | #{num_calls} | #{time} |"
    end
  end

  # Aggregate the time it takes to run a block of code.
  # Returns the value of the block.
  # At exit, it will output the aggregated time.
  def _ta(label)
    $agg[label] ||= { time: 0, num_calls: 0 }
    t = Process.clock_gettime(Process::CLOCK_MONOTONIC)
    ret = yield
  ensure
    $agg[label][:time] += (Process.clock_gettime(Process::CLOCK_MONOTONIC) - t)
    $agg[label][:num_calls] += 1
    ret
  end
    </code>
  </pre>

  <h4 class="text-xl font-semibold">Example Code</h4>
  <pre>
    <code class="ruby">
  i = 0

  # This will react the same as _t
  # except the result is deferred to the end
  _ta('basic') do
    puts i
  end

  # This will react the same as _t
  # except the result is deferred to the end
  _ta('longer') do
    while i < 30
      i += 1
      sleep 0.1
    end
  end

  # _ta is called many times here
  # But because it is aggregated - we only see once at the end
  def my_method(i = 0)
    _ta('method') do
      return if i > 20
      sleep 0.1
      my_method(i + 1)
    end
  end

  my_method
    </code>
  </pre>

  <h4 class="text-xl font-semibold">Output</h4>
  <pre>
    <code class="shell">
  0
  | line   | num_calls | time (s)              |
  | ------ | --------- | --------------------- |
  | basic  | 1         | 3.600001218728721e-05 |
  | longer | 1         | 3.0774530000053346    |
  | method | 22        | 23.5655019999831      |
  => nil
    </code>
  </pre>
</div>

    <div class="py-6">
  <h2 class="text-2xl font-semibold">Gantt Charts</h2>
  <p>Aggregating the times was a great step to improve usability of the code.</p>
  <p>But we can visualize the information to improve it even more. <a href="https://en.wikipedia.org/wiki/Gantt_chart">Gantt Charts</a> are a common engineering tool that can help here.</p>
  <p>This code outputs a syntax that can be consumed by my <a href="https://rubygems.org/gems/chart_helpers">Chart Helpers Gem</a>.</p>
  <pre>
    <code class="ruby">
  require 'chart_helpers'
  require 'date'

  # We use a global aggregate cache to allow us to track methods within a loop all at once
  $timed = {}

  at_exit do
    $timed.each do |method_name, timed_hash|
      output = []

      # Output Chart Helpers syntax for gantt
      title_file = timed_hash[:path].dup
      title_file.gsub!(ENV.fetch('GEM_HOME', 'GEM_HOME'), '')
      title_file.gsub!(ENV.fetch('HOME', 'USER'), '')
      output << "gantt"
      output << "   title file: #{title_file} method: #{method_name}"

      curr_percent = 0.000

      # Aggregate the lines together. Loops can cause things to become unweildly otherwise
      @grouped_lines = timed_hash[:entries].group_by do |line|
        [line[:line], line[:line_no]]
      end

      # Calculate total time for all groups
      total_group_time = ->(group) do
        gantt_chart_time = 0.000024 * group.size # 0.000024 is an approximation
        time = group.collect { |e| e[:time] }.inject(:+) - gantt_chart_time
        time < 0.001 ? 0.001 : time
      end
      total_time = @grouped_lines.collect { |_, group| total_group_time.call(group) }.inject(:+)

      @grouped_lines.each do |(group_name, _line_no), group|
        # If we have run more than once, we should indicate how many times something is called
        entry_name = group.size > 1 ? "#{group_name} (run #{group.size} times)" : group_name
        entry_name = entry_name.tr('"', "'").tr(",", ' ') # Sometimes Chart Helpers has trouble with these

        # Total time for all entries to run
        time = total_group_time.call(group)
        percent = (time / total_time * 100)

        # Output the line
        post_percent = percent + curr_percent
        output << format("   \"%s\" :a1, %.3f, %.3f", entry_name, curr_percent, post_percent)
        curr_percent = post_percent
      end

      output << "\n\n"

      file_name = "output/#{method_name}.svg"
      puts "Outputting chart to #{file_name}"
      # Could also output the `output` content instead
      # The original intention of the library was to use
      # human readable/writeable syntax
      ChartHelpers.render_chart(output.join("\n"), file_name)
    end
  end

  def _gantt_chart
    ret = nil

    # Determine the method and path that we're calling from
    call_loc = caller_locations.reject { |l| l.path.include?('byebug') }.first
    method_name = call_loc.label
    path = call_loc.path
    source = File.readlines(path)

    unless $timed[method_name]
      puts "Tracing #{path} for method #{method_name}"
      $timed[method_name] = { path: path, entries: [], calls: 0 }
    end

    # This block will be used to finalize the time it to run, gather the line source, etc.
    finalize_time = -> () do
      if last = $timed[method_name][:entries].pop
        # Finalize the time
        return if last[:start].nil? # Sometimes at the end it can mess up
        time = Process.clock_gettime(Process::CLOCK_MONOTONIC) - last[:start]
        # Get the source line from the line number
        line = source[last[:line_no] - 1].strip
        next if line.include?('_gantt_chart')
        $timed[method_name][:entries] << { line_no: last[:line_no], line: line, time: time }
      end
    end

    # We use Ruby's tracepoint on a per line basis
    # We only care about lines called within our method and within our path
    trace = TracePoint.new(:line) do |tp|
      next unless tp.path == path
      next unless tp.method_id.to_s == method_name.to_s

      # We could have a call from last time, finalize it, we've moved to a new line
      finalize_time.call
      # Initialize a new entry with the line number and a start time
      $timed[method_name][:entries] << { line_no: tp.lineno, start: Process.clock_gettime(Process::CLOCK_MONOTONIC) }
    end

    begin
      trace.enable do
        ret = yield
      end
    ensure
      finalize_time.call # The last call needs to be finalized, finalize it here
    end

    ret
  end
    </code>
  </pre>

  <h4 class="text-xl font-semibold">Example Code</h4>
  <pre>
    <code class="ruby">
  # This is the basic example of a gantt chart
  # Each line takes about an equal amount of time
  def my_method(i)
    _gantt_chart do
      puts i
      return if i > 200
      my_method(i + 1)
    end
  end

  # This shows the difference when one line takes a lot longer than the others
  # You can see the `sleep` line takes a lot longer than the other lines
  def my_method_2(i)
    _gantt_chart do
      puts i
      return if i > 20
      sleep 0.1
      my_method_2(i + 1)
    end
  end

  my_method(0)
  my_method_2(0)
    </code>
  </pre>

  <h4 class="text-xl font-semibold">Output</h4>
  <a href="/images/my_method-0a296850.png">
    <img src="/images/my_method-0a296850.png" width="100%" alt="" />
  </a>
  <a href="/images/my_method_2-4534a1bb.png">
    <img src="/images/my_method_2-4534a1bb.png" width="100%" alt="" />
  </a>
</div>

    <h3>Put it all together</h3>
    <p>With all of these you can end up creating flow charts and gantt charts to determine slow paths in the code.</p>
    <p><a href="/images/flowcharts.JPG"><img src="/images/flowcharts_small-67628eb5.jpeg" width="700" alt="" /></a></p>
  </div>
</section>


    <footer>
      <div class="wrapper">© <span id="cp-year">2026</span> Julian Nadeau</div>
    </footer>
    <script>
      document.getElementById('cp-year').textContent = new Date().getFullYear();
      (function() {
        var stored = localStorage.getItem('theme');
        var prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
        if (stored === 'dark' || (!stored && prefersDark)) document.documentElement.classList.add('dark');
        document.getElementById('theme-toggle').addEventListener('click', function() {
          document.documentElement.classList.toggle('dark');
          localStorage.setItem('theme', document.documentElement.classList.contains('dark') ? 'dark' : 'light');
        });
      })();
    </script>
  </body>
</html>
